## ethers.js 合约部署和读写

### 1. 合约编写

-   编写一个 ERC1155 的智能合约，继承了 OpenZeppelin ERC1155 和 Ownable 合约
-   合约中有两个私有映射变量 \_tokenSupply 和 \_tokenURIs，分别用于存储每个 ERC1155 代币的供应量和 URI
-   在构造函数中，传入了基础 URI，用于确定代币的元数据
-   mint 函数可供所有者调用来铸造新的 ERC1155 代币。该函数调用了 \_mint 函数将新代币的供应量添加到特定帐户中
-   \_tokenSupply 和 \_tokenURIs 映射都会更新，并触发 TokenMinted 事件。 该事件记录了代币 ID，代币供应量和代币 URI。tokenId 参数使用 indexed 修饰符进行标记，以便在事件日志中可以更快速地搜索并访问该参数。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.0/contracts/token/ERC1155/ERC1155.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.0/contracts/access/Ownable.sol";

contract MyERC1155 is ERC1155, Ownable {

    mapping(uint256 => uint256) private _tokenSupply;
    mapping(uint256 => string) private _tokenURIs;

    event TokenMinted(uint256 indexed tokenId, uint256 supply, string uri);

    constructor(string memory uri) ERC1155(uri) {}

    function mint(uint256 tokenId, uint256 supply, string memory uri) public onlyOwner {
        _mint(msg.sender, tokenId, supply, "");
        _tokenSupply[tokenId] += supply;
        _tokenURIs[tokenId] = uri;
        emit TokenMinted(tokenId, supply, uri);
    }

    function tokenSupply(uint256 tokenId) public view returns (uint256) {
        return _tokenSupply[tokenId];
    }

    function uri(uint256 tokenId) public view override returns (string memory) {
        return _tokenURIs[tokenId];
    }
}
```

### 2. 合约编译

编译工具:

-   [[在线remix]](https://remix.ethereum.org/)
-   solc 工具

编译结果

-   字节码(bytecode): 是 solidity 代码被翻译以后的信息，包含了二进制的计算机指令。
-   ABI: 应用程序二进制接口,以 json 文件表示。

### 3. 合约部署和读写操作

可以查看此目录下的完整脚本： L10_sample.html
